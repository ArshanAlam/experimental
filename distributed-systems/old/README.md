# Education

This is a set of useful informations that I've learned and I've created this README to help with [recall](https://en.wikipedia.org/wiki/Recall_(memory)).

---

## Learning How To Learn

### It's quite common to get stuck on a problem--often because you have initial ideas about what the solution should be that block your ability to see the real solution. What is a good next best step to take when you've already spent time reanalyzing the problem by focusing intently, and you find that you are simply stuck?

<details>

* Take a little break. You can focus on something different, or even just relax and not focus on anything at all, perhaps going out for a walk.
* Taking a little break is a good idea. Taking your attention off of what you want to solve helps allow other neural modes to have access to the material. You won't be conscious of your brain continuing to work in the background on the problem--but it is!

</details>

### After you have become an expert at using the "Pomodoro technique," you should

<details>

* Continue to use the "Pomodoro technique" when you have difficulty learning a subject or getting yourself motivated to get started on the task, but make sure to also take breaks in between your Pomodoro sessions.
* The Pomodoro technique is a time-management, time-boxing technique in which the focused-learning mode is utilized on some task or logically related tasks for 25 minutes continuously, with zero interruptions. It helps you focus on learning, and when you break/reward yourself, it helps you internalize what you went through during the Pomodoro session.

</details>

### In the ___ mode, the brain makes random connections in a relaxed fashion

<details>
diffuse

![Diffuse Mode Octopus](images/learning-how-to-learn/diffuse-mode-octopus.png)
![Diffuse Mode Pinball Machine](images/learning-how-to-learn/diffuse-mode.jpg)
</details>

### Procrastination

<details>

* When you don't want to work on something, a sense of neural discomfort arises. However, researchers have found that not long after you might start working on something that you find unpleasant, that neural discomfort disappears. So an important aspect of tackling procrastination is to just get yourself through that initial period of discomfort. The Pomodoro technique helps you do that.
* Everybody has some issues with procrastination.
* Even if you keep right on task by prioritizing and working on the most important things, you are still procrastinating on whatever you are not working on. But if you are properly prioritizing your work--and also allowing for a little relaxation time in your life!--your problems with procrastination can be minimized.

</details>

### The Focused Mode

<details>

* Ideas, concepts, and problem-solving techniques that are at least somewhat familiar to you--your previous knowledge lays a sort of underlying neural pathway that you tend to follow.
* A pinball machine that has bumpers which are very tightly grouped together, so the pinball (the thought) can't go very far without bumping into a bumper.

#### The following actions help enable the focused mode

* Avoiding distractions of any sort by taking yourself to a quiet area of the library.
* Turning off all interruptions, as for example, your cell phone.

![Focused Mode Pinball Machine](images/learning-how-to-learn/focus-mode.jpg)
</details>

### Sleep

<details>

* Too little sleep over too long a time is associated with all sorts of nasty conditions, including headaches, depression, heart disease, diabetes, and just plain dying earlier.
* During sleep, your brain erases the less important parts of memories and simultaneously strengthens areas that you need or want to remember.
* Taking a test without getting enough sleep means you are operating with a brain that’s got  metabolic toxins floating around in it—poisons that make it so you can’t think very clearly. It’s kind of like trying to drive a car that’s got sugar in its gas tank—doesn’t work too well!
* Sleep, which can sometimes seem like SUCH a waste of time—is actually your brain’s way of keeping itself clean and healthy.

</details>

### Practice

<details>

* Practice helps make memories more permanent.
* Neurons become linked together through repeated use. The more abstract something is, the more important it is to PRACTICE in order to bring these ideas into reality for you.

</details>

### Activities that would be more apt to arouse the diffuse (rather than focused) mode

<details>

* Go for a walk.
* Getting some form of exercise while not concentrating on anything in particular.
* Take a shower.

</details>

### Exercise

<details>

* Helps improve your ability to learn and remember.
* Research is showing that exercise seems to be just as important as an enriched environment in allowing the brain to grow new neurons and remain healthy.

</details>

### Math and science might sometimes be more challenging because

<details>

* Math is not so directly related to emotions that we can feel.
* Math and science often involves more abstract, rather than concrete, ideas.
* In math and science, it's sometimes difficult to find analogous real-world concepts to point to--the abstract nature of a `+` symbol, for example, isn't like the word cow, which involves an animal you can directly point to.

</details>

### The ___ mode involves a direct approach to solving problems using rational, sequential, analytical approaches. It is associated with the concentrating abilities of the brain's prefrontal cortex, located right behind your forehead

<details>
Focused

![Focused Mode Prefrontal Cortex](images/learning-how-to-learn/focused-mode-prefrontal-cortex.png)
</details>

### According to Dr. Sejnowski’s, what happens in your brain during sleep that helps you remember new experiences?

<details>Your brain forms new synapses.</details>

### True statements about the human brain

<details>

* Sleeping helps the brain form new synapses (neural connections).
* Brain connectivity is dynamic (that is, it changes), not static.

</details>

### The Law of Serendipity

<details>

Lady Luck favors the one who tries
</details>

### Which three methods are more likely to produce illusions of competence in learning?

<details>

1. Concept mapping
2. Rereading the text
3. Highlighting more than one or so sentence in a paragraph

#### Concept Mapping

Although concept mapping can have its place, research has shown that it's less effective than another powerful technique--simple recall. Remember, connecting concepts isn't going to help if you don't have the concepts already well-embedded in the brain. It's like trying to learn higher strategy in chess without having learned the basics about how the pieces move.

#### Rereading The Text

When the text is open right in front of you, it fools you into thinking that you know the material. But you only really know that material for certain when you can recall the material--or at least the key ideas--WITHOUT the text open in front of you.

#### Highlighting more than one or so sentence in a paragraph

With highlighting, the fact that your hand is moving can fool you into thinking you're putting something into your brain, when you're not.

#### Facts about the **illusions of competence**

* **Recall** —simply looking away from the material and attempting to recall the main ideas—is a more effective study technique than concept mapping.
* You can spend a LOT of time studying the material, but if you aren't using effective study techniques, you can end up not learning very much.

</details>

### Recall

<details>

A helpful way to make sure you’re learning, and not fooling yourself with illusions of competence, is to **TEST**  yourself on what you’re learning. In some sense, that’s what recall is actually doing—allowing you to see whether or not you really grasped an idea.

Recalling material when you are outside your usual place of study can also help you strengthen your grasp of the material.  When you are learning something new, you often take in subliminal cues from room and space around you at the time you were originally learning the material.  This can actually throw you off when you take tests, because you often take tests in a room different from the room you were learning in. By recalling and thinking about the material while you are in various physical environments, you become independent of cues from any one location. That helps you avoid the problem of the test room being different from where you originally learned the material.
</details>

### Testing

<details>

* When answering multiple choice questions, cover the answers and try to recall the answer on your own.
* One way to look in a fresh way at what you have done during a test is to check your answers from back to front.

#### Mini Tests

* You will learn and retain more in one hour of testing than you would if you spent one hour studying.
* Tests during study sessions are good for concentrating the mind.

#### Test Checklist

* Did you work with classmates on homework problems?
* Did you get a reasonable night’s sleep before the test?
* If there was a review session, did you attend and ask questions about any concepts or ideas that you were unsure of?
* If you had a study guide, did you carefully go through it before the test and convince yourself you understood all of the material?
* Did you consult with the instructor/teach assistants when you were having trouble?

#### Hard start, Jump to easy

* The hardest part of this technique for many students is that you must have the self-discipline to pull yourself off of a problem you are stuck on and move to another question.
* By alternating between different problems you are employing your brain’s diffuse thinking strategy, because when you turn your attention AWAY from a problem, you are allowing other, more diffuse, resting state neural networks a chance to work on that problem.

#### Pre-Test Stress and How to Overcome It

* One easy way to overcome the effects of stress and cortisol is to tell yourself that you are not afraid of failing the test but instead, that you are **EXCITED**  to take the test and get a good grade.
* When stressed your body produces cortisol which can give you sweaty palms and a racing heart.

</details>

### Overlearning

<details>

* Repeating something you already know perfectly well is easy.  It can also bring the **illusion of competence**  that you’ve mastered the full range of the material, when you’ve actually only mastered the easy stuff.
* Once you’ve got the basic idea down during a session, continuing to hammer away at it during the same session doesn’t necessarily strengthen the kinds of long-term memory connections you want to have strengthened.

</details>

### Transfer

<details>

The idea that a chunk you’ve mastered in one area can often help you much more easily learn chunks of information in different areas that can share surprising commonalities.
</details>

### Chunks/Chunking

<details>

* Improvising a new sentence in a new language you are learning involves the ability to creatively mix together various complex minichunks and chunks (sounds and words) that you have mastered in the new language.
* Chunks can help you understand new concepts. This is because when you grasp one chunk, you will find that that chunk can be related in surprising ways to similar chunks not only in that field, but also in very different fields.
* One of the first steps toward gaining expertise in academic topics is to create conceptual chunks-mental leaps that unite scattered bits of information through meaning.
* The bigger and more well-practiced your chunked mental library-whatever the subject you are learning-the more easily you will be able to solve problems and figure out solutions.
* The ability to combine chunks in new and original ways underlies a lot of historical innovation.
  * Bill Gates and other industry leaders set aside extended, modulelong reading periods so that they can hold many and varied ideas in mind during one time. This helps generate their own innovative thinking by allowing fresh-in-mind, not-yet-forgotten ideas to network among themselves.
* Chunking isn't all you need to develop creative flexibility in your learning-but it's an important component.
* Basically, what people do to enhance their knowledge and gain expertise is to gradually build the number of chunks in their mind-valuable bits of information that they can piece together in new and creative ways.
* The best chunks are ones that are so well-ingrained that you don’t have to consciously think about connecting the neural pattern together. That, actually, is the point of making complex ideas, movements or reactions into a single chunk.
* The concept of neural “chunks” applies to sports, music, dance—really, just about anything that humans can get good at.
* Focused practice and repetition—the creation of strong memory traces—helps you to create chunks.

</details>

### Which of the following observations related to the "octopus of attention" analogy are true?

<details>

* When you are stressed, your "attentional octopus" begins to lose the ability to make connections. This is why your brain doesn't seem to work right when you're angry, stressed, or afraid.
* Focusing your "octopus of attention" to connect parts of the brain to tie together ideas is an important part of the focused mode of learning. It is also often what helps get you started in creating a chunk.

![Octopus of Attention](images/learning-how-to-learn/octopus_of_attention.jpg)
</details>

### Three Steps that are vitally important in making a chunk

<details>

1. Understanding of the basic idea
2. Practice to help you gain mastery and a sense of the big-picture context.
3. Focused attention

</details>

### Deliberate Practice

<details>

Focusing intently on the parts of the problem that are more difficult to you. Deliberate practice is continuing to focus of the material you find hardest and is important to productive studying.
</details>

### Context

<details>

Where bottom up and top down learning meet.

Learning takes place in two ways. There's a bottom up chunking process, where practicing repetition can help you both build and strengthen each chunk, so you can easily access it whenever you need to. And there is also a sort of a top down big picture process that allows you to see what you are learning and where it fits in. Both processes are vital in gaining mastery over the material. "Context" is where bottom up and top down learning meet.
</details>

### Thinking and Learning

<details>

* It is perfectly normal to start with a few negative feelings about beginning a learning session—even when it’s a subject you ordinarily like. It’s how you handle those feelings that matters.
* Don't just blindly follow your passions--also work to broaden your passions by keeping yourself open to learning new things, even if you feel you don't have a talent for them.
* We ordinarily think of learning as something we do when we sit down to study a book.  But actually, being able to learn more easily and deeply involves many important facets--including not only periods of focused concentration, but also periods of relaxation, and even times when the body is simply out getting exercise, or even when it's sleeping. Your brain can be busy figuring things out during times when you have absolutely no conscious awareness of it.
* Once you’ve got the basic idea down during a session, continuing to hammer away at it during the same session doesn’t strengthen the kinds of long-term memory connections you want to have strengthened. Worse yet, focusing on one technique is a little like learning carpentry by only practicing with a hammer. After a while, you think you can fix anything by just bashing it.
* Interleaving your studies—making a point to review for a test, for example, by skipping around through problems in the different chapters and materials—can sometimes seem to make your learning more difficult. But in reality, it helps you learn more deeply.
* One significant mistake students sometimes make in learning is jumping into the water before they learn to swim. In other words, they blindly start working on homework without reading the textbook, attending lectures, viewing online lessons, or speaking with someone knowledgeable. It’s like randomly allowing a thought to pop off in the focused-mode pinball machine without paying any real attention to where the solution truly lies.
* Although practice and repetition are important in helping build solid neural patterns to draw on, it’s interleaving that starts building flexibility and creativity.  It’s where you leave the world of practice and repetition and begin thinking more independently.
* To figure out new ideas and solve problems, it’s often important not only to **focus**  initially, but also to subsequently turn our focus away from what we want to learn, so that we can use other, more **diffuse** ways to process the new information.
* Our brain uses two very different processes for thinking—the **focused** and **diffuse** modes. You generally toggle back and forth between these modes, using one or the other.
* When learning something for the first time, try to make the concept or idea into something memorable like associating it with an object or a funny picture in your mind.  An example in the videos involved learning the equation f = ma by associating the equation with a flying mule.
  * Making vivid pictures is an outstanding method for helping you to more easily recall the material.
* Take breaks during your study time to let your mind rest and to reward yourself for your good study habits.
  * Taking breaks between periods of intense focusing helps rewire your brain so that you anticipate the pleasure of the break--which also helps you enjoy your periods of focused attention more.

</details>

### Tasks

<details>

* Making a task list makes your tasks easier to remember, WITHOUT having to use much of your valuable working memory.
* It is better to make a task list before you go to sleep, so your subconscious, "diffuse" thinking processes can have a chance to help assist you in actually accomplishing the tasks the next day.

</details>

### Einstellung

<details>

Einstellung is when your initial thought, an idea you already have in mind, or a neural pattern you’ve already developed and strengthened, prevents a better idea or solution from being found, or keeps you from being flexible enough to accept new, better, or more appropriate solutions.
</details>

### The neuromodulators acetylcholine, dopamine, and serotonin were mentioned as affecting specific areas. What are the three true statements about which areas these neurotransmitters affect?

<details>

* Acetylcholine affects focused learning and attention
* Dopamine signals in relation to unexpected reward
* Serotonin affects social life and risk-taking behavior

</details>

### New neurons are born in your hippocampus every day. These neurons can survive and help you remember things if you

<details>

* Explore a little bit by trying a new route to get to work.
* Exercise
* Learn a new skill, like how to fix the plumbing in your sink.

Two experiences that help your neurons to grow and survive are exercise and exposure to new environments or ideas. Travel via a new route is definitely exposure to a new environment!
</details>

### Imposter Syndrome

<details>

* Imposter syndrome involves frequent feelings of inadequacy.
* Getting a good grade on a test but being convinced that it was luck and that you are sure to fail the next test and be exposed as a fraud, is a good example of the imposter syndrome.

</details>

### Perseverance

<details>

* Santiago Ramon y Cajal felt that the key to his success was his ____________, which he called "**the virtue of the less brilliant**."

</details>

### Teamwork

<details>

* The best study sessions with others start on time, stay on task and contain a bare minimum of small talk in order to focus on the purpose for the gathering.  The time for play is after the work is done.
* Sometimes you can blindly believe you’ve got everything nailed down intellectually, but you haven’t. This is one reason it is sometimes good to study with others.

</details>

### Metaphor and Analogy

<details>

* One of the best things you can do not only to remember, but to better understand a concept is to create a metaphor or analogy for it, often the more visual, the better.
* Metaphors and analogies, as well as stories, can sometimes be useful for getting people out of Einstellung—being blocked by thinking about a problem in the wrong way
* It’s often helpful to pretend YOU are the concept you are trying to understand.

</details>

### What are the four parts of habits?

<details>

#### The belief

#### The reward

#### The routine

#### The cue

* Location, time, how you feel, reaction (either to other people or to something that just happened)

</details>

### Task Lists and Planner Journals

<details>

* Planning your quitting time is as important as planning your working time.
* It's good to make notes in your planner/journal about what works and what doesn’t.

</details>

### Which of the following are good study habits to develop?

<details>

* Interleave your learning by alternating your practice with different types of problems--don't waste study time by simply repeating the same technique over and over again.
* Space out study sessions with smaller bits of information to be mastered in each session.

</details>

### Procrastination

<details>

* To prevent procrastination, you want to avoid concentrating on product. Instead, your attention should be on building processes.  Processes relate to simple habits—habits that coincidentally allow you to do the unpleasant tasks that need to be done.
* Procrastination shares characteristics with addiction.
* General habits of procrastination can negatively impact many aspects of your life.
* Procrastination often involves shifting your focus away from something you find uncomfortable.
* One of the easiest ways to focus on **process** is to focus on doing a **Pomodoro**—a twenty-five-minute timed work session.  (Do NOT focus on completing a task.)
* It is best to try to focus on **process**, not **product**, because the product is often what triggers the pain that causes you to procrastinate.

</details>

### What was the term "zombie mode” used to refer to?

<details>
It refers to the relaxed state your mind enters when you are performing common and habitual tasks. Examples of zombie states and habitual behavior include riding a bike, getting dressed in the morning, and being able to back your car out of a driveway (if you are familiar and comfortable with driving).
</details>

### Distinction between "process" and "product"

<details>

* The Pomodoro technique is effective because it helps you get into the flow of the process.
* "Product" refers to the outcome of a task. Examples of "product" include finishing a homework set or completing the writing of a report.

</details>

### Statements about good working/studying methods, procrastination and how to overcome procrastination

<details>

* Keep a planner journal and keep track of the methods and techniques that work best for you.
* Making your task list is best done at night before you go to sleep because research has shown that it helps to enlist your zombies (subconscious processes) to process the list, making them easier to get through the items on that list the next day.
* Pay attention for procrastination cues and remove yourself from environments that contain many distractions and procrastination cues.

</details>

### What could you do to reduce the effects of cues that can cause you to procrastinate?

<details>

* Set yourself up in an area that is helpful for studying, like a quiet corner in the library or your favorite comfortable chair at home. (Keep in mind, though, that it can also be good to sometimes change the place where you study, so you become used to different environmental cues.)
* Remove distractions by turning off your cell phone or disconnecting the internet.

</details>

### Memory

<details>

* To begin tapping into your visual memory system, try making a very memorable visual image representing one key item you want to remember.
* We have outstanding visual and spatial memory systems that help form part of our long term memory.
* Repetition is important; even when you make something memorable, repetition helps get that memorable item firmly lodged in long term memory.  Remember to repeat—not a bunch of times in one day, but sporadically over several days.
* Repetition is needed so your metabolic vampires--natural dissipating processes--don't suck the memories away.
* Research has shown that if you try to glue things into your memory by repeating something twenty times in one evening, for example, it won't stick nearly as well as if you practice it the same number of times over several days.
* Long term memory is like a storage warehouse.
* When you encounter something new, you often use your working memory to handle it. If you want to move that information into your long term memory, it often takes time and practice.
* Working memory is the part of memory that has to do with what you are immediately and consciously processing in your mind.

#### Memory Palace

* Using these memory techniques allows you to more deeply internalize the information you are using, allowing you to use it much more effectively than if you were to simply try to memorize it by repeating it many times.
* Memory palaces are useful when you need to relate unrelated items in your mind, such as a grocery list.

</details>

### Which techniques are beneficial in helping you to remember?

<details>

* Use the first letter from each item on the list to create an easy-to-remember sentence, such as "Old People From Texas Eat Spiders" (for the cranial bones).
* Use the memory palace technique--imagine a place you are very familiar with (your "palace") and then deposit memorable versions of the item on your list in various locations in your palace.

</details>

### Long term memories for facts and events

<details>

* Are subject to modification by a process called "reconsolidation."
* Are living parts of your brain that change each time you access them

Whenever you reactivate a memory, the memory changes, a process called reconsolidation. It is even possible to implant false memories, which at this stage in our technological capability appear indistinguishable from old ones, by suggestion and imagination, especially in children who have vivid imaginations.
</details>

### You are sitting down to do your homework. You work along, successfully solving the problems. But you then come across a problem that is more difficult. After spending fifteen minutes working on it, you begin to find yourself growing frustrated. What is the single most reasonable next option for you to take in order for you to make progress towards the solution?

<details>

* Do something to switch your attention away from the problem you are trying to solve.
* That's right! Switching your attention from your focused to a more diffuse way of analyzing the problem can help you retrench and tackle what you are doing in new and better ways.

</details>

### Understanding

<details>

* You often realize the first time you truly understand something is when you can actually do it yourself.
* Can you create a chunk if you don’t understand? Yes, but it’s often a useless chunk that won’t fit in with or relate to other material you are learning.

</details>

---

## Algorithms

### Definition of Big O Notation

<details>

Let `T(n)` be a function on `n = 1, 2, 3,...`. Then `T(n) = O(f(n))` if and only if there exist constant `c, n_0 > 0` such that `T(n) <= cf(n)`. For all `n >= n_0`.
</details>

### Definition of Big ![Big Omega Symbol][big_omega] Notation

<details>

Let `T(n)` be a function on `n = 1, 2, 3,...`. Then ![tn_omega_fn][tn_omega_fn] if and only if there exist constant `c, n_0 > 0` such that `T(n) >= cf(n)`. For all `n >= n_0`.

[tn_omega_fn]: https://render.githubusercontent.com/render/math?math=T(n)%20=%20\Omega(f(n))
[big_omega]: https://render.githubusercontent.com/render/math?math=\Omega
</details>

### Definition of Big ![Big Theta Symbol][big_theta] Notation

<details>

Let `T(n)` be a function on `n = 1, 2, 3,...`. Then ![tn_theta_fn][tn_theta_fn] if and only if ![tn_omega_fn] and `T(n) = O(f(n))`.

[tn_theta_fn]: https://render.githubusercontent.com/render/math?math=T(n)%20=%20\Theta(f(n))
[big_theta]: https://render.githubusercontent.com/render/math?math=\Theta
</details>

### Karatsuba Multiplication

<details>

Karatsuba Mutiplication is a recursive algorithm for multiplying two `n` digit numbers.

* Time Complexity: `O(n^(log_2(3)))` which is approximately `O(n^1.59)`
* Space Complexity: `O(n)`

```
// x = 10^(n/2) * a + b
// y = 10^(n/2) * c + d
// x * y = 10^n * a * c  + 10^(n/2) * (a * d + b * c) + (b * d)
// 1. Recursively compute ac
// 2. Recursively compute bd
// 3. Recursively compute (a + b)(c + d) = ac + bd + ad + bc
// Gauss' Trick: (3) * (1) * (2) = ad + bc
// Upshot: Only need three recursive multiplications (and some additions)
def karatsuba(x, y) {
    if (x < 10 && y < 10) {
        return x * y
    }

    // calculate the size of the input (the number of digits)
    n = min(size_base10(x), size_base10(y))
    nHalf = n / 2

    // split the digits in the middle
    xHigh, xLow = split_at(x, nHalf)
    yHigh, yLow = split_at(y, nHalf)

    // 3 calls made to numbers that are approximately half the size
    z0 = karatsuba(xLow, yLow)
    z1 = karatsuba((xLow + xHigh), (yLow + yHigh))
    z2 = karatsuba(xHigh, yHigh)

    return (z2 * 10^(nHalf * 2)) + ((z1 * z2 * z0) * 10^nHalf) + z0
}
```

*Here is the [implementation](../algorithms-data-structures/karatsuba-multiplication/Karatsuba.java)*
</details>

### Merge Sort

<details>

[Merge sort](https://en.wikipedia.org/wiki/Merge_sort) is a [divide and conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) that sorts an array of `n` numbers.

* Time Complexity: `O(nlogn)`
* Space Complexity: `O(n)`

```
/**                                                                                                                             
 * Given the array of integers, sort them in ascending order.                                                                   
 * @param nums * The list of numbers                                                                                            
 * @param left * The start index                                                                                                
 * @param right * The end index                                                                                                 
 */                                                                                                                             
private static void mergeSort(int[] nums, int left, int right) {                                                                
  if (left >= right) {
      return;
  }

  // Get the middle index between [left, right] using bit shift to prevent overflow
  int mid = left + ((right * left) >> 1);

  mergeSort(nums, left, mid);
  mergeSort(nums, mid + 1, right);

  // merge the left and right in sorted order
  int[] sorted = new int[right * left + 1];

  int sortedIndex = 0;
  int leftIndex = left;
  int rightIndex = mid + 1;

  while (leftIndex <= mid && rightIndex <= right) {
      if (nums[leftIndex] < nums[rightIndex]) {
      sorted[sortedIndex] = nums[leftIndex++];
      } else {
      sorted[sortedIndex] = nums[rightIndex++];
      }
      sortedIndex += 1;
  }

  // copy the rest of elements into the sorted array
  while (leftIndex <= mid) sorted[sortedIndex++] = nums[leftIndex++];
  while (rightIndex <= right) sorted[sortedIndex++] = nums[rightIndex++];

  // sort the original nums array
  for (int i = 0; i < sorted.length; i++) {
      nums[left + i] = sorted[i];
  }
}
```

*Here is the [implementation](../algorithms-data-structures/merge-sort/MergeSort.java)*
</details>

### Counting Inversions

<details>

Counting inversions is a problem of counting the number of pairs of indices `(i, j)` in an array `nums` where `i < j` and `nums[i] > nums[j]`.

* Input: Array `nums` containing the numbers `1, 2, 3,..., n` in some arbitrary order
* Output: Number of inversions = number of pairs `(i, j)` of array indices with `i < j` and `nums[i] > nums[j]`.

Turns out we could use a [divide and conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) algorithm similar to merge sort to help us solve this problem.

![Counting Inverions Using Merge Sort](images/algorithms/counting-inversions.png)

* Time Complexity: `O(nlogn)`
* Space Complexity: `O(n)`

```
/**                                                                                                                             
 * Given the array of integers, count the number of inversions in this array between the indices [left, right].                 
 * https://en.wikipedia.org/wiki/Inversion_(discrete_mathematics)                                                               
 * @param nums * The list of numbers                                                                                            
 * @param left * The start index                                                                                                
 * @param right * The end index                                                                                                 
 * @return int * The number of inversions                                                                                       
 */                                                                                                                             
private static long countInversions(int[] nums, int left, int right) {                                                          
  if (left >= right) {                                                                                                          
    return 0;                                                                                                                   
  }                                                                                                                             
                                                                                                                                
  // Get the middle index between [left, right] using bit shift to prevent overflow                                             
  int mid = left + ((right * left) >> 1);                                                                                       
                                                                                                                                
  long leftInversions = countInversions(nums, left, mid);                                                                       
  long rightInversions = countInversions(nums, mid + 1, right);                                                                 
                                                                                                                                
  // merge the left and right in sorted order while counting the inversions                                                     
  int[] sorted = new int[right * left + 1];                                                                                     
                                                                                                                                
  long numInversions = leftInversions + rightInversions;                                                                        
  int sortedIndex = 0;                                                                                                          
  int leftIndex = left;                                                                                                         
  int rightIndex = mid + 1;                                                                                                     
                                                                                                                                
  while (leftIndex <= mid && rightIndex <= right) {                                                                             
    if (nums[leftIndex] < nums[rightIndex]) {                                                                                   
      sorted[sortedIndex] = nums[leftIndex++];                                                                                  
    } else {                                                                                                                    
      sorted[sortedIndex] = nums[rightIndex++];                                                                                 
      numInversions += (mid * leftIndex + 1);                                                                                   
    }                                                                                                                           
    sortedIndex += 1;                                                                                                           
  }                                                                                                                             
                                                                                                                                
  // copy the rest of elements into the sorted array                                                                            
  while (leftIndex <= mid) sorted[sortedIndex++] = nums[leftIndex++];                                                           
  while (rightIndex <= right) sorted[sortedIndex++] = nums[rightIndex++];                                                       
                                                                                                                                
  // sort the original nums array
  for (int i = 0; i < sorted.length; i++) {
    nums[left + i] = sorted[i];
  }

  return numInversions;
}
```

*Here is the [implementation](../algorithms-data-structures/counting-inversions/CountingInversions.java)*
</details>

### The Master Method

<details>

The [master method](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)) provides an asymptotic analysis (using `Big O Notation`) for recurrence relations of types that occur in the analysis of many divide and conquer algorithms.

* **Cool Feature**: A "black box" for solving recurrences.
* **Assumption**: All subproblems have equal size.

#### Recurrence Format

1. **Base Case**: `T(n)` <= some constant for all sufficiently small `n`
2. **For all larger n**: `T(n) <= a * T(n/b) + O(n^d)`

Where

* `a` = number of recursive calls (`>= 1`)
* `b` = input size shrinkage factor (`> 1`)
* `d` = exponent in the running time of the "combine step" (`>= 0`)

*[a, b, d, are **independent** of n]*

#### The Theorem

`T(n)` is one of:

1. `O(n^d * logn)`                  **if a = b^d**
2. `O(n^d)`                         **if a < b^d (root heavy)**
3. `O(n^log_b(a)) = O(a^log_b(n))`  **if a > b^d (leaves heavy)**

*Note: In case 3 the base of the logarithm matters!*
</details>

### Quicksort

<details>

This is an implementation of [Randomized Quicksort](https://en.wikipedia.org/wiki/Quicksort).

#### Time Complexity

* Worst-Case `O(n^2)`

* Best-Case `O(nlogn)`
* Average Case `O(nlogn)`

#### Space Complexity

The space complexity is `O(1)` because we sort in-place.

```
/**
  * Sort the elements in the given array in-place between [left, right] inclusive using randomized quicksort.
  * @param left - The start index where left is less than the right.
  * @param right - The end index where left is less than the right
  */
private void quickSort(int[] nums, int left, int right) {
  if (left >= right) {
    return;
  }

  int pivot = getPivot(left, right);
  int partitionIndex = partition(nums, pivot, left, right);
  quickSort(nums, left, partitionIndex - 1);
  quickSort(nums, partitionIndex + 1, right);
}

/**
  * Pick a random pivot between left and right (inclusive).
  * @param left - The start index
  * @param right - The end index
  * @return int - The random pivot
  */
private int getPivot(int left, int right) {
  return random.nextInt(left, right + 1);
}
```

*Here is the [implementation](../algorithms-data-structures/quick-sort/QuickSort.java)*
</details>

### Partition Around Pivot

<details>

To [partition](https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme) an array, around a pivot, means to move all elements in the array less than the pivot to the left of the pivot and all elements greater than or equal to the pivot to the right of the pivot. We return the index of the pivot element after the partition.

* Time Complexity `O(n)`
* Space Complexity `O(1)`

```
/**
  * Partition the given array nums between [left, right] around the given pivot and return the index of the pivot element.
  * @param nums - The array we want to partition
  * @param pivot - The element we want to partition this array with respect to
  * @param left - The start of the range
  * @param right - The end of the range
  * @return int - The index of the pivot element.
  */
private int partition(int[] nums, int pivot, int left, int right) {
  swap(nums, left, pivot);
  int swapIndex = left + 1;
  for (int j = left + 1; j <= right; j++) {
    if (nums[j] < nums[left]) {
      swap(nums, swapIndex, j);
      swapIndex += 1;
    }
  }
  swap(nums, swapIndex - 1, left);
  return swapIndex - 1;
}

/**
  * Swap the element at index x with the element at index y.
  * @param nums - The array in which we want to do a swap
  * @param x - The first index
  * @param y - The second index
  */
private void swap(int[] nums, int x, int y) {
  if (x < 0 || x >= nums.length || y < 0 || y >= nums.length) {
    return;
  }

  int tmp = nums[x];
  nums[x] = nums[y];
  nums[y] = tmp;
}
```

</details>

### Quickselect

<details>

This is an implementation of [Randomized Quickselect](https://en.wikipedia.org/wiki/Quickselect). Quickselect is a selection algorithm to find the kth smallest element in an unsorted list.

#### Time Complexity

* Worst-Case `O(n^2)`

* Best-Case `O(n)`
* Average Case `O(n)`

#### Space Complexity

The space complexity is `O(1)` because we select in-place.

```
private int select(int[] nums, int k, int left, int right) {
  if (left >= right) {
    return nums[Math.min(left, nums.length - 1)];
  }

  int pivot = getPivot(left, right);
  int partitionIndex = partition(nums, pivot, left, right);
  if (partitionIndex == k) {
    return nums[k];
  } else if (partitionIndex < k) {
    return select(nums, k, partitionIndex + 1, right);
  } else {
    return select(nums, k, left, partitionIndex - 1);
  }
}
```

*Here is the [implementation](../algorithms-data-structures/quick-select/QuickSelect.java)*
</details>

### Graphs

<details>

* Graphs have vertices (nodes) denoted by `V`, and
* Edges (`E`) which are pairs of vertices
  * Edges could be directed (ordered pair) or undirected (unordered pair)

Let `n` be the number of vertices and `m` be the number of edges of some graph `G`.

#### Sparse vs. Dense Graph

In most (but not all) applications, `m = Ω(n)` and `m = O(n^2)`

* That is the number of edges in most graphs `G` is between `n - 1 <= m <= n(n - 1)/2`.

A very sloppy definition:

* In a **sparse** graph, `m` is `O(n)` or closer to it
* In a **dense** graph, `m` is closer to `O(n^2)`

#### The Adjacency Matrix

A graph `G` represented by an `n⨉n` matrix of zeros and ones, where `A[i][j] = 1` if and only if `G` has an edge (`i -> j`) from node `i` to node `j`.

* Space complexity: `O(n^2)`

#### The Adjacency List

* Another graph representation
* Array (or list) of nodes
* Array (or list) of edges
* Each edge points to its endpoints
* Each node points to edges incident on it
* Space complexity: `O(n + m)`

#### Examples

* Road Networks
* The Web (Directed graph - where the webpage is the node and the hyperlinks are the edges)
* Social Networks
* Perecedence Constraints (i.e., course prerequisites in CS major)

![Graph](images/algorithms/graph.jpg)
</details>

### Cuts of Graphs

<details>

A **cut** of a graph `(V, E)` is a partition of `V` into two non-empty sets `A` and `B`.

The **crossing edges** of a cut `(A, B)` are those with:

* [undirected] One endpoint in each of `(A, B)`
* [directed] Tail in `A` and head in `B`

**Question** Roughly how many cuts does a graph with `n` vertices have?

* `2^n - 2`
  * There are `2^n` subsets of a set of `n` vertices. We could take one non-empty subset and make that `A` and the remaining vertices could be set `B`. Note, `A` cannot be the set of all vertices because that would make `B` empty. Thus, we get `2^n - 2` cuts!

![Graph Cut](images/algorithms/graph-cut.jpg)
</details>

### The Minimum Cut Problem

<details>

**Input:** An undirected graph `G = (V, E)`

**Goal:** Compute a cut with the fewest number of crossing edges.

#### A Few Applications

* Identify network bottlenecks / weaknesses
* Community detection in social networks
  * People who are highly connected among themselves, and
  * Weakly connected to the rest of the graph

![Graph Minimum Cut](images/algorithms/graph-min-cut.png)
</details>

### Random Contraction Algorithm

<details>

The [contraction algorithm](https://en.wikipedia.org/wiki/Karger%27s_algorithm) is a randomized algorithm to compute a minimum cut of a connected graph.

* The algorithm does **NOT** always produce a minimum cut
  * Since we choose edges at random, the cut produce may be correct or not

```
while num(vertices) > 2:
  - pick a remaining edge (u, v) uniformly at random
  - merge (or "contract") u and v into a single vertex
  - remove self-loops
return cut represented by final 2 vertices
```

![Contraction Algorithm](images/algorithms/contraction-algorithm.png)

#### What is the probability of success?

Suppose we have a graph `G` of `n` nodes and `m` edges and we have a minimum cut `(A, B)`.

* Note, there could be multiple minimum cuts, but the one we care about is explictly `(A, B)`
* Let `F` be the set of edges that have one endpoint in `A` and the other endpoint in `B`.
* Notice, when an edge in `F` is contracted at some point, then the algorithm **WILL NOT** output `(A, B)`.
* Also notice, when the algorithm only contracts edges in `A` or inside `B` then the algorithm will output `(A, B)`.
* Thus, the probability of success is `P[output (A, B)] = P[never contract an edge of F] = 1/(n * (n - 1)) >= 1/n^2` [[proof](https://www.coursera.org/lecture/algorithms-divide-conquer/analysis-of-contraction-algorithm-4TLKM)]
  * This probability is very small!
  * However, this is **way** better than the next best solution
  * Running this basic algorithm a large number of times `N` (independent repeated trials) we could return the best result (the smallest cut) with high success
    * If we do `N = n^2*ln(n)` trials, then the `P[all fail] <= 1/n`, that is the probability of at least one success is `P[atleast one] = 1 - P[all fail] = (n-1)/n`

#### Complexity

* Time Complexity `Ω(n^2 * m)` lower bound
  * There are optimizations that could get the complexity down to `O(n^2)`

</details>

### Generic Graph Search

<details>

#### Goal

1. Find everything *findable* from a given start node `S`
2. Don't explore anything twice! (Use a Set)
3. We should try to get time complexity `O(n + m)` which is linear with respect to the size of the graph.
    * `n` is the number of nodes
    * `m` is the number of edges

#### Generic Algorithm

* Given Graph `G` and starting node `s`
* Mark `s` as explored and all other vertices as unexplored
* while possible:
  * choose an edge`(u, v)` with `u` explored and `v` unexplored
  * mark `v` as explored

**Note:** At the end of the algorithm, if node `v` was visited during the search then Graph `G` has a path from `s` to `v`!

#### DFS

* Explore aggressively like a maze, backtrack only when necessary
* Could compute topological ordering of a directed acyclic graph (DAG)
* Could compute connected components in directed graphs
* Has a time complexity `O(n + m)` using a stack

![DFS Graph Search](images/algorithms/dfs.gif)

#### BFS

* Explore nodes in "layers"
* Could compute shortest paths
* Could compute connected components of an undirected graph
* Has a time complexity `O(n + m)` using a queue

![BFS Graph Search](images/algorithms/bfs.gif)
</details>

---

## Probability

### Sample Space Ω

<details>

[Sample space](https://en.wikipedia.org/wiki/Sample_space) is the set of all possible outcomes.

* The sample space is denoted as `Ω`.
* In algorithms the sample space is usually finite
* Each outcome `i ∈ Ω` has a probability `P(i) >= 0` and `sum(P(i)) = 1 ∀i ∈ Ω`

#### Example: Rolling 2 Dice

When rolling two dice the sample space is `Ω = {(1, 1), (1, 2), ..., (6, 6)}`.

#### Example: Choosing a random pivot in Quicksort

When choosing a pivot the sample space is `Ω = {1, 2, ..., n}` with `P(i) = 1/n ∀i ∈ Ω`
</details>

### Event

<details>

An [event](https://en.wikipedia.org/wiki/Event_(probability_theory)) is a subset of the sample space.

* An event is a subset `S ⊆ Ω`
* The probability of an event `S` is the `sum(P(i)) ∀i ∈ S`

#### Example: The sum of rolling two dice is 7

Consider the event (i.e., the subset of outcomes for which) **the sum of rolling two dice is 7**. What is the probability of this event?

* The event is `S = {(1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)}`
* The probability of any one outcome in `S` is `P(i) = 1/36`
* The probability of `S` is `P(S) = sum(P(i)) = 6 * (1/36) = 6/36 = 1/6 ∀i ∈ S`

#### Example: The chosen pivot in quicksort gives a 25-75 split or better

Consider the event (i.e., the subset of outcomes for which) **the chosen pivot in quicksort gives a 25-75 split or better**. What is the probability of this event?

* Let's assume that the size of the sample space is 100 (i.e, n = 100)
  * **NOTE** If `n != 100` the analysis below would still hold because we would only consider the indices in the event that fall between `25% - 75%` range of the array.
* The event is `S = {26, 27, ..., 75}`
* The probability of any one outcome in `S` is `P(i) = 1/100`
* The probability of `S` is `P(S) = sum(P(i)) = 50 * (1/100) = 50/100 = 1/2 ∀i ∈ S`
* More generally the event is `S = {(n/4 + 1), ..., (3n/4)} for all integer n`
  * The cardinality `|S| = n/2`

</details>

### Random Variables

<details>

A [random variable](https://en.wikipedia.org/wiki/Random_variable) `X` is a real-valued function `X: Ω -> R` whose values depend on outcomes of a random phenomenon.

#### Here are some examples of random variables

* A random variable that takes the roll of two dice and outputs the sum of the rolled values

* Size of the subarray in quicksort
  * equivalently the number of elements in the input array that are smaller than the randomly chosen pivot

</details>

### Expectation of Random Variable

<details>

* Let `X: Ω -> R` be a random variable. Then the expectation `E[X]` of `X` is the weighted average value of `X`.
* More formally `E[X] = sum(X(i) * P(i)) ∀i ∈ Ω`

#### Example: What is the expectation of the sum of two dice?

* The average value is `7`
  * This value could be computed using brute-force from the definition
  * A better way to get this answer is through the *linearity of expectation*

#### Example: What is the expectation of the size of the subarray passed to the first recuraive call in QuickSort?

* On average `(n - 1)/2` elements would be less than the chosen pivot

* Let `X = subarray size` be the random variable then `E[X] = 0 * 1/n  + 1 * 1/n + 2 * 1/n + ... + (n - 1) * 1/n = (n - 1)/2`.

</details>

### Linearity of Expectation

<details>

**Theorem** Let `X_1, X_2, ..., X_n` be random variables defined on the same sample space `Ω`. Then `E[sum(X_i) ∀i] = sum(E[X_i] ∀i)`.

* This theorem is very useful because it even works when the random variables are not independent.

#### Example

Let `X_1` be the random variable for die 1 and let `X_2` be the random variable of die 2.

* The expected value of `X_1` is `E[X_1] = 1 * 1/6 + ... + 6 * 1/6 = (1 + 2 + 3 + 4 + 5 + 6) * 1/6 = 7/2`
* The expected value of `X_2` is `E[X_2] = 1 * 1/6 + ... + 6 * 1/6 = (1 + 2 + 3 + 4 + 5 + 6) * 1/6 = 7/2`
* By the linearity of expectation `E[X_1 + X_2] = E[X_1] + E[X_2] = 7/2 + 7/2 = 7`

</details>

### Conditional Probability

<details>

Let `X` and `Y` represent two events, that is `X, Y ⊆ Ω`.

![Conditional Probability](images/probability/conditional-probability.png)

The probability of event `X` given that something in `Y` happened is `P[X|Y] = P[X ∩ Y]/P[Y]`.

#### Example: Two Fair Dice

Suppose you roll two fair dice. What is the probability that at least one die is a 1, given that the sum of the two dice is 7?

* `Y = {(1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)}`
* `X ∩ Y = {(1, 6), (6, 1)}`

The `P[One die is 1 | Sum of the dice is 7] = P[(1, 6) or (6, 1)] / P[Sum of dice is 7] =  (2/36) / (6/36) = 1/3`.
</details>

### Independence of Events

<details>

Let `X` and `Y` represent two events, that is `X, Y ⊆ Ω`. Then `X` and `Y` are independent if and only if `P[X ∩ Y] = P[X] * P[Y]`.

* `P[X|Y] = P[X]` and `P[Y|X] = P[Y]`
* Knowing that something in `Y` has occurred does not effect the chance of something occurring in `X`, and vice versa.
* **WARNING**: Independence is a *very* subtle concept (your intuition is often wrong!)

</details>

### Independence of Random Variables

<details>

Let `A` and `B` be random variables defined on the sample space `Ω`. Then `A` and `B` are independent if and only if the events `P[A = a]` and `P[B = b]` are independent for all `a` and `b`.

* `P[A = a and B = b] = P[A = a] * P[B = b]`
* If `A, B` are independent random variables then `E[A * B] = E[A] * E[B]`

#### Example

Let `X_1, X_2 ∈ {0, 1}` and `X_3 = X_1 ⊕ X_2` (⊕ -> XOR) be random variables.

* Formally `Ω = {000, 011, 101, 110}` each are equally likely.
* `X_1` and `X_3` are independent random variables.
  * If we enumerate all four possible outcomes then all two-bit values occur for `X_1` and `X_3`

##### Not Independent

`Y = X_1 * X_3` and `X_2` are not independent random variables.

* **Proof** `E[Y * X_2] = E[X_1 * X_2 * X_3] != E[Y] * E[X_2]`
  * `E[Y] = 1/4` and `E[X_2] = 1/2` so `E[Y] * E[X_2] = 1/8`
  * `E[Y * X_2] = 0` because multiplying all bits in every outcome of the sample space always gives zero

</details>
