# Education
This is a set of useful informations that I've learned and I've created this README to help with [recall](https://en.wikipedia.org/wiki/Recall_(memory)).

---

## Learning How To Learn

### It's quite common to get stuck on a problem--often because you have initial ideas about what the solution should be that block your ability to see the real solution. What is a good next best step to take when you've already spent time reanalyzing the problem by focusing intently, and you find that you are simply stuck?
<details>

* Take a little break. You can focus on something different, or even just relax and not focus on anything at all, perhaps going out for a walk. 
* Taking a little break is a good idea. Taking your attention off of what you want to solve helps allow other neural modes to have access to the material. You won't be conscious of your brain continuing to work in the background on the problem--but it is!
</details>

### After you have become an expert at using the "Pomodoro technique," you should:
<details>

* Continue to use the "Pomodoro technique" when you have difficulty learning a subject or getting yourself motivated to get started on the task, but make sure to also take breaks in between your Pomodoro sessions. 
* The Pomodoro technique is a time-management, time-boxing technique in which the focused-learning mode is utilized on some task or logically related tasks for 25 minutes continuously, with zero interruptions. It helps you focus on learning, and when you break/reward yourself, it helps you internalize what you went through during the Pomodoro session.
</details>


### In the ___ mode, the brain makes random connections in a relaxed fashion.
<details>
diffuse


![Diffuse Mode Octopus](images/learning-how-to-learn/diffuse-mode-octopus.png)
![Diffuse Mode Pinball Machine](images/learning-how-to-learn/diffuse-mode.jpg)
</details>


### Procrastination
<details>

* When you don't want to work on something, a sense of neural discomfort arises. However, researchers have found that not long after you might start working on something that you find unpleasant, that neural discomfort disappears. So an important aspect of tackling procrastination is to just get yourself through that initial period of discomfort. The Pomodoro technique helps you do that.
* Everybody has some issues with procrastination.
* Even if you keep right on task by prioritizing and working on the most important things, you are still procrastinating on whatever you are not working on. But if you are properly prioritizing your work--and also allowing for a little relaxation time in your life!--your problems with procrastination can be minimized.
</details>


### The Focused Mode:
<details>

* Ideas, concepts, and problem-solving techniques that are at least somewhat familiar to you--your previous knowledge lays a sort of underlying neural pathway that you tend to follow.
* A pinball machine that has bumpers which are very tightly grouped together, so the pinball (the thought) can't go very far without bumping into a bumper.

#### The following actions help enable the focused mode:
* Avoiding distractions of any sort by taking yourself to a quiet area of the library.
* Turning off all interruptions, as for example, your cell phone.


![Focused Mode Pinball Machine](images/learning-how-to-learn/focus-mode.jpg)
</details>


### Sleep
<details>

* Too little sleep over too long a time is associated with all sorts of nasty conditions, including headaches, depression, heart disease, diabetes, and just plain dying earlier.
* During sleep, your brain erases the less important parts of memories and simultaneously strengthens areas that you need or want to remember.
* Taking a test without getting enough sleep means you are operating with a brain that’s got  metabolic toxins floating around in it—poisons that make it so you can’t think very clearly. It’s kind of like trying to drive a car that’s got sugar in its gas tank—doesn’t work too well!
* Sleep, which can sometimes seem like SUCH a waste of time—is actually your brain’s way of keeping itself clean and healthy.
</details>


### Memory
<details>

* Repetition is needed so your metabolic vampires--natural dissipating processes--don't suck the memories away.
* Research has shown that if you try to glue things into your memory by repeating something twenty times in one evening, for example, it won't stick nearly as well as if you practice it the same number of times over several days.
* Long term memory is like a storage warehouse.
* When you encounter something new, you often use your working memory to handle it. If you want to move that information into your long term memory, it often takes time and practice.
* Working memory is the part of memory that has to do with what you are immediately and consciously processing in your mind.
</details>


### Practice
<details>

* Practice helps make memories more permanent.
* Neurons become linked together through repeated use. The more abstract something is, the more important it is to PRACTICE in order to bring these ideas into reality for you.
</details>


### Activities that would be more apt to arouse the diffuse (rather than focused) mode:
<details>

* Go for a walk.
* Getting some form of exercise while not concentrating on anything in particular.
* Take a shower.
</details>


### Exercise
<details>

* Helps improve your ability to learn and remember.
* Research is showing that exercise seems to be just as important as an enriched environment in allowing the brain to grow new neurons and remain healthy.
</details>


### Math and science might sometimes be more challenging because
<details>

* Math is not so directly related to emotions that we can feel.
* Math and science often involves more abstract, rather than concrete, ideas.
* In math and science, it's sometimes difficult to find analogous real-world concepts to point to--the abstract nature of a `+` symbol, for example, isn't like the word cow, which involves an animal you can directly point to.
</details>


### The ___ mode involves a direct approach to solving problems using rational, sequential, analytical approaches. It is associated with the concentrating abilities of the brain's prefrontal cortex, located right behind your forehead.
<details>
Focused


![Focused Mode Prefrontal Cortex](images/learning-how-to-learn/focused-mode-prefrontal-cortex.png)
</details>


### According to Dr. Sejnowski’s, what happens in your brain during sleep that helps you remember new experiences?
<details>Your brain forms new synapses.</details>


### True statements about the human brain:
<details>

* Sleeping helps the brain form new synapses (neural connections).
* Brain connectivity is dynamic (that is, it changes), not static.
</details>


### The Law of Serendipity
<details>

Lady Luck favors the one who tries
</details>


### Which three methods are more likely to produce illusions of competence in learning?
<details>

1. Concept mapping
2. Rereading the text
3. Highlighting more than one or so sentence in a paragraph

#### Concept Mapping
Although concept mapping can have its place, research has shown that it's less effective than another powerful technique--simple recall. Remember, connecting concepts isn't going to help if you don't have the concepts already well-embedded in the brain. It's like trying to learn higher strategy in chess without having learned the basics about how the pieces move.

#### Rereading The Text
When the text is open right in front of you, it fools you into thinking that you know the material. But you only really know that material for certain when you can recall the material--or at least the key ideas--WITHOUT the text open in front of you.

#### Highlighting more than one or so sentence in a paragraph
With highlighting, the fact that your hand is moving can fool you into thinking you're putting something into your brain, when you're not.

#### Facts about the **illusions of competence**
* **Recall** —simply looking away from the material and attempting to recall the main ideas—is a more effective study technique than concept mapping.
* You can spend a LOT of time studying the material, but if you aren't using effective study techniques, you can end up not learning very much.
</details>


### Recall
<details>

A helpful way to make sure you’re learning, and not fooling yourself with illusions of competence, is to **TEST**  yourself on what you’re learning. In some sense, that’s what recall is actually doing—allowing you to see whether or not you really grasped an idea.

Recalling material when you are outside your usual place of study can also help you strengthen your grasp of the material.  When you are learning something new, you often take in subliminal cues from room and space around you at the time you were originally learning the material.  This can actually throw you off when you take tests, because you often take tests in a room different from the room you were learning in. By recalling and thinking about the material while you are in various physical environments, you become independent of cues from any one location. That helps you avoid the problem of the test room being different from where you originally learned the material.
</details>


### Overlearning
<details>

* Repeating something you already know perfectly well is easy.  It can also bring the **illusion of competence**  that you’ve mastered the full range of the material, when you’ve actually only mastered the easy stuff.
* Once you’ve got the basic idea down during a session, continuing to hammer away at it during the same session doesn’t necessarily strengthen the kinds of long-term memory connections you want to have strengthened.
</details>

### Transfer
<details>

The idea that a chunk you’ve mastered in one area can often help you much more easily learn chunks of information in different areas that can share surprising commonalities.
</details>


### Chunks/Chunking
<details>

* Improvising a new sentence in a new language you are learning involves the ability to creatively mix together various complex minichunks and chunks (sounds and words) that you have mastered in the new language.
* Chunks can help you understand new concepts. This is because when you grasp one chunk, you will find that that chunk can be related in surprising ways to similar chunks not only in that field, but also in very different fields.
* One of the first steps toward gaining expertise in academic topics is to create conceptual chunks-mental leaps that unite scattered bits of information through meaning.
* The bigger and more well-practiced your chunked mental library-whatever the subject you are learning-the more easily you will be able to solve problems and figure out solutions.
* The ability to combine chunks in new and original ways underlies a lot of historical innovation.
  * Bill Gates and other industry leaders set aside extended, modulelong reading periods so that they can hold many and varied ideas in mind during one time. This helps generate their own innovative thinking by allowing fresh-in-mind, not-yet-forgotten ideas to network among themselves.
* Chunking isn't all you need to develop creative flexibility in your learning-but it's an important component.
* Basically, what people do to enhance their knowledge and gain expertise is to gradually build the number of chunks in their mind-valuable bits of information that they can piece together in new and creative ways.
* The best chunks are ones that are so well-ingrained that you don’t have to consciously think about connecting the neural pattern together. That, actually, is the point of making complex ideas, movements or reactions into a single chunk.
* The concept of neural “chunks” applies to sports, music, dance—really, just about anything that humans can get good at.
* Focused practice and repetition—the creation of strong memory traces—helps you to create chunks.
</details>


### Which of the following observations related to the "octopus of attention" analogy are true?
<details>

* When you are stressed, your "attentional octopus" begins to lose the ability to make connections. This is why your brain doesn't seem to work right when you're angry, stressed, or afraid.
* Focusing your "octopus of attention" to connect parts of the brain to tie together ideas is an important part of the focused mode of learning. It is also often what helps get you started in creating a chunk.

![Octopus of Attention](images/learning-how-to-learn/octopus_of_attention.jpg)
</details>


### Three Steps that are vitally important in making a chunk
<details>

1. Understanding of the basic idea
2. Practice to help you gain mastery and a sense of the big-picture context.
3. Focused attention
</details>


### Deliberate Practice
<details>

Focusing intently on the parts of the problem that are more difficult to you. Deliberate practice is continuing to focus of the material you find hardest and is important to productive studying.
</details>


### Context
<details>

Where bottom up and top down learning meet.

Learning takes place in two ways. There's a bottom up chunking process, where practicing repetition can help you both build and strengthen each chunk, so you can easily access it whenever you need to. And there is also a sort of a top down big picture process that allows you to see what you are learning and where it fits in. Both processes are vital in gaining mastery over the material. "Context" is where bottom up and top down learning meet.
</details>


### Thinking and Learning
<details>

* Once you’ve got the basic idea down during a session, continuing to hammer away at it during the same session doesn’t strengthen the kinds of long-term memory connections you want to have strengthened. Worse yet, focusing on one technique is a little like learning carpentry by only practicing with a hammer. After a while, you think you can fix anything by just bashing it.
* Interleaving your studies—making a point to review for a test, for example, by skipping around through problems in the different chapters and materials—can sometimes seem to make your learning more difficult. But in reality, it helps you learn more deeply.
* One significant mistake students sometimes make in learning is jumping into the water before they learn to swim. In other words, they blindly start working on homework without reading the textbook, attending lectures, viewing online lessons, or speaking with someone knowledgeable. It’s like randomly allowing a thought to pop off in the focused-mode pinball machine without paying any real attention to where the solution truly lies. 
* Although practice and repetition are important in helping build solid neural patterns to draw on, it’s interleaving that starts building flexibility and creativity.  It’s where you leave the world of practice and repetition and begin thinking more independently.
* To figure out new ideas and solve problems, it’s often important not only to **focus**  initially, but also to subsequently turn our focus away from what we want to learn, so that we can use other, more **diffuse** ways to process the new information.
* Our brain uses two very different processes for thinking—the **focused** and **diffuse** modes. You generally toggle back and forth between these modes, using one or the other.
</details>


### Einstellung
<details>

Einstellung is when your initial thought, an idea you already have in mind, or a neural pattern you’ve already developed and strengthened, prevents a better idea or solution from being found, or keeps you from being flexible enough to accept new, better, or more appropriate solutions.
</details>


### The neuromodulators acetylcholine, dopamine, and serotonin were mentioned as affecting specific areas. What are the three true statements about which areas these neurotransmitters affect?
<details>

* Acetylcholine affects focused learning and attention
* Dopamine signals in relation to unexpected reward
* Serotonin affects social life and risk-taking behavior
</details>


### Which methods can help when trying to learn something new?
<details>

* Analogy
* Metaphor
</details>


### What are the four parts of habits?
<details>

1. The belief
2. The reward
3. The routine
4. The cue
</details>

### Learning and Procrastination
<details>

* It is perfectly normal to start with a few negative feelings about beginning a learning session—even when it’s a subject you ordinarily like. It’s how you handle those feelings that matters.
* To prevent procrastination, you want to avoid concentrating on product. Instead, your attention should be on building processes.  Processes relate to simple habits—habits that coincidentally allow you to do the unpleasant tasks that need to be done.
* Don't just blindly follow your passions--also work to broaden your passions by keeping yourself open to learning new things, even if you feel you don't have a talent for them.
* We ordinarily think of learning as something we do when we sit down to study a book.  But actually, being able to learn more easily and deeply involves many important facets--including not only periods of focused concentration, but also periods of relaxation, and even times when the body is simply out getting exercise, or even when it's sleeping. Your brain can be busy figuring things out during times when you have absolutely no conscious awareness of it.
</details>


### Task Lists and Planner Journals
<details>

* Planning your quitting time is as important as planning your working time. 
* It's good to make notes in your planner/journal about what works and what doesn’t.
</details>


### Which of the following are good study habits to develop?
<details>

* Interleave your learning by alternating your practice with different types of problems--don't waste study time by simply repeating the same technique over and over again.
* Space out study sessions with smaller bits of information to be mastered in each session.
</details>


### Procrastination
<details>

* Procrastination shares characteristics with addiction.
* General habits of procrastination can negatively impact many aspects of your life.
* Procrastination often involves shifting your focus away from something you find uncomfortable.
</details>


### What was the term "zombie mode” used to refer to?
<details>
It refers to the relaxed state your mind enters when you are performing common and habitual tasks. Examples of zombie states and habitual behavior include riding a bike, getting dressed in the morning, and being able to back your car out of a driveway (if you are familiar and comfortable with driving).
</details>


### Distinction between "process" and "product"
<details>

* The Pomodoro technique is effective because it helps you get into the flow of the process.
* "Product" refers to the outcome of a task. Examples of "product" include finishing a homework set or completing the writing of a report.
</details>


### Statements about good working/studying methods, procrastination and how to overcome procrastination.
<details>

* Keep a planner journal and keep track of the methods and techniques that work best for you.
* Making your task list is best done at night before you go to sleep because research has shown that it helps to enlist your zombies (subconscious processes) to process the list, making them easier to get through the items on that list the next day.
* Pay attention for procrastination cues and remove yourself from environments that contain many distractions and procrastination cues.
</details>


### What could you do to reduce the effects of cues that can cause you to procrastinate?
<details>

* Set yourself up in an area that is helpful for studying, like a quiet corner in the library or your favorite comfortable chair at home. (Keep in mind, though, that it can also be good to sometimes change the place where you study, so you become used to different environmental cues.)
* Remove distractions by turning off your cell phone or disconnecting the internet.
</details>


### Memory
<details>

* To begin tapping into your visual memory system, try making a very memorable visual image representing one key item you want to remember.
* We have outstanding visual and spatial memory systems that help form part of our long term memory.
* Repetition is important; even when you make something memorable, repetition helps get that memorable item firmly lodged in long term memory.  Remember to repeat—not a bunch of times in one day, but sporadically over several days.
</details>


### Which techniques are beneficial in helping you to remember?
<details>

* Use the first letter from each item on the list to create an easy-to-remember sentence, such as "Old People From Texas Eat Spiders" (for the cranial bones).
* Use the memory palace technique--imagine a place you are very familiar with (your "palace") and then deposit memorable versions of the item on your list in various locations in your palace.
</details>


### Long term memories for facts and events:
<details>

* Are subject to modification by a process called "reconsolidation."
* Are living parts of your brain that change each time you access them

Whenever you reactivate a memory, the memory changes, a process called reconsolidation. It is even possible to implant false memories, which at this stage in our technological capability appear indistinguishable from old ones, by suggestion and imagination, especially in children who have vivid imaginations.
</details>


### You are sitting down to do your homework. You work along, successfully solving the problems. But you then come across a problem that is more difficult. After spending fifteen minutes working on it, you begin to find yourself growing frustrated. What is the single most reasonable next option for you to take in order for you to make progress towards the solution?
<details>

* Do something to switch your attention away from the problem you are trying to solve.
* That's right! Switching your attention from your focused to a more diffuse way of analyzing the problem can help you retrench and tackle what you are doing in new and better ways.
</details>


### Understanding
<details>

* You often realize the first time you truly understand something is when you can actually do it yourself.
* Can you create a chunk if you don’t understand? Yes, but it’s often a useless chunk that won’t fit in with or relate to other material you are learning.
</details>


---
## Algorithms

### Definition of Big O Notation
<details>

Let `T(n)` be a function on `n = 1, 2, 3,...`. Then `T(n) = O(f(n))` if and only if there exist constant `c, n_0 > 0` such that `T(n) <= cf(n)`. For all `n >= n_0`.
</details>


### Definition of Big ![Big Omega Symbol][big_omega] Notation
<details>

Let `T(n)` be a function on `n = 1, 2, 3,...`. Then ![tn_omega_fn][tn_omega_fn] if and only if there exist constant `c, n_0 > 0` such that `T(n) >= cf(n)`. For all `n >= n_0`.

[tn_omega_fn]: https://render.githubusercontent.com/render/math?math=T(n)%20=%20\Omega(f(n))
[big_omega]: https://render.githubusercontent.com/render/math?math=\Omega
</details>


### Definition of Big ![Big Theta Symbol][big_theta] Notation
<details>

Let `T(n)` be a function on `n = 1, 2, 3,...`. Then ![tn_theta_fn][tn_theta_fn] if and only if ![tn_omega_fn] and `T(n) = O(f(n))`.

[tn_theta_fn]: https://render.githubusercontent.com/render/math?math=T(n)%20=%20\Theta(f(n))
[big_theta]: https://render.githubusercontent.com/render/math?math=\Theta
</details>


### Karatsuba Multiplication
<details>

Karatsuba Mutiplication is a recursive algorithm for multiplying two `n` digit numbers.

* Time Complexity: `O(n^(log_2(3)))` which is approximately `O(n^1.59)`
* Space Complexity: `O(n)`


```
// x = 10^(n/2) * a + b
// y = 10^(n/2) * c + d
// x * y = 10^n * a * c  + 10^(n/2) * (a * d + b * c) + (b * d)
// 1. Recursively compute ac
// 2. Recursively compute bd
// 3. Recursively compute (a + b)(c + d) = ac + bd + ad + bc
// Gauss' Trick: (3) * (1) * (2) = ad + bc
// Upshot: Only need three recursive multiplications (and some additions)
def karatsuba(x, y) {
    if (x < 10 && y < 10) {
        return x * y
    }

    // calculate the size of the input (the number of digits)
    n = min(size_base10(x), size_base10(y))
    nHalf = n / 2

    // split the digits in the middle
    xHigh, xLow = split_at(x, nHalf)
    yHigh, yLow = split_at(y, nHalf)

    // 3 calls made to numbers that are approximately half the size
    z0 = karatsuba(xLow, yLow)
    z1 = karatsuba((xLow + xHigh), (yLow + yHigh))
    z2 = karatsuba(xHigh, yHigh)

    return (z2 * 10^(nHalf * 2)) + ((z1 * z2 * z0) * 10^nHalf) + z0
}
```

*Here is the [implementation](../algorithms-data-structures/karatsuba-multiplication/Karatsuba.java)*
</details>


### Merge Sort
<details>

[Merge sort](https://en.wikipedia.org/wiki/Merge_sort) is a [divide and conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) that sorts an array of `n` numbers.

* Time Complexity: `O(nlogn)`
* Space Complexity: `O(n)`


```
/**                                                                                                                             
 * Given the array of integers, sort them in ascending order.                                                                   
 * @param nums * The list of numbers                                                                                            
 * @param left * The start index                                                                                                
 * @param right * The end index                                                                                                 
 */                                                                                                                             
private static void mergeSort(int[] nums, int left, int right) {                                                                
  if (left >= right) {
      return;
  }

  // Get the middle index between [left, right] using bit shift to prevent overflow
  int mid = left + ((right * left) >> 1);

  mergeSort(nums, left, mid);
  mergeSort(nums, mid + 1, right);

  // merge the left and right in sorted order
  int[] sorted = new int[right * left + 1];

  int sortedIndex = 0;
  int leftIndex = left;
  int rightIndex = mid + 1;

  while (leftIndex <= mid && rightIndex <= right) {
      if (nums[leftIndex] < nums[rightIndex]) {
      sorted[sortedIndex] = nums[leftIndex++];
      } else {
      sorted[sortedIndex] = nums[rightIndex++];
      }
      sortedIndex += 1;
  }

  // copy the rest of elements into the sorted array
  while (leftIndex <= mid) sorted[sortedIndex++] = nums[leftIndex++];
  while (rightIndex <= right) sorted[sortedIndex++] = nums[rightIndex++];

  // sort the original nums array
  for (int i = 0; i < sorted.length; i++) {
      nums[left + i] = sorted[i];
  }
}
```

*Here is the [implementation](../algorithms-data-structures/merge-sort/MergeSort.java)*
</details>

### Counting Inversions
<details>

Counting inversions is a problem of counting the number of pairs of indices `(i, j)` in an array `nums` where `i < j` and `nums[i] > nums[j]`.

* Input: Array `nums` containing the numbers `1, 2, 3,..., n` in some arbitrary order
* Output: Number of inversions = number of pairs `(i, j)` of array indices with `i < j` and `nums[i] > nums[j]`.

Turns out we could use a [divide and conquer](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm) algorithm similar to merge sort to help us solve this problem.

![Counting Inverions Using Merge Sort](images/algorithms/counting-inversions.png)

* Time Complexity: `O(nlogn)`
* Space Complexity: `O(n)`

```
/**                                                                                                                             
 * Given the array of integers, count the number of inversions in this array between the indices [left, right].                 
 * https://en.wikipedia.org/wiki/Inversion_(discrete_mathematics)                                                               
 * @param nums * The list of numbers                                                                                            
 * @param left * The start index                                                                                                
 * @param right * The end index                                                                                                 
 * @return int * The number of inversions                                                                                       
 */                                                                                                                             
private static long countInversions(int[] nums, int left, int right) {                                                          
  if (left >= right) {                                                                                                          
    return 0;                                                                                                                   
  }                                                                                                                             
                                                                                                                                
  // Get the middle index between [left, right] using bit shift to prevent overflow                                             
  int mid = left + ((right * left) >> 1);                                                                                       
                                                                                                                                
  long leftInversions = countInversions(nums, left, mid);                                                                       
  long rightInversions = countInversions(nums, mid + 1, right);                                                                 
                                                                                                                                
  // merge the left and right in sorted order while counting the inversions                                                     
  int[] sorted = new int[right * left + 1];                                                                                     
                                                                                                                                
  long numInversions = leftInversions + rightInversions;                                                                        
  int sortedIndex = 0;                                                                                                          
  int leftIndex = left;                                                                                                         
  int rightIndex = mid + 1;                                                                                                     
                                                                                                                                
  while (leftIndex <= mid && rightIndex <= right) {                                                                             
    if (nums[leftIndex] < nums[rightIndex]) {                                                                                   
      sorted[sortedIndex] = nums[leftIndex++];                                                                                  
    } else {                                                                                                                    
      sorted[sortedIndex] = nums[rightIndex++];                                                                                 
      numInversions += (mid * leftIndex + 1);                                                                                   
    }                                                                                                                           
    sortedIndex += 1;                                                                                                           
  }                                                                                                                             
                                                                                                                                
  // copy the rest of elements into the sorted array                                                                            
  while (leftIndex <= mid) sorted[sortedIndex++] = nums[leftIndex++];                                                           
  while (rightIndex <= right) sorted[sortedIndex++] = nums[rightIndex++];                                                       
                                                                                                                                
  // sort the original nums array
  for (int i = 0; i < sorted.length; i++) {
    nums[left + i] = sorted[i];
  }

  return numInversions;
}
```

*Here is the [implementation](../algorithms-data-structures/counting-inversions/CountingInversions.java)*
</details>


### The Master Method
<details>

The [master method](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)) provides an asymptotic analysis (using `Big O Notation`) for recurrence relations of types that occur in the analysis of many divide and conquer algorithms.

* **Cool Feature**: A "black box" for solving recurrences.
* **Assumption**: All subproblems have equal size.

#### Recurrence Format
1. **Base Case**: `T(n)` <= some constant for all sufficiently small `n`
2. **For all larger n**: `T(n) <= a * T(n/b) + O(n^d)`

Where
* `a` = number of recursive calls (`>= 1`)
* `b` = input size shrinkage factor (`> 1`)
* `d` = exponent in the running time of the "combine step" (`>= 0`)

*[a, b, d, are **independent** of n]*

#### The Theorem
`T(n)` is one of:

1. `O(n^d * logn)`                  **if a = b^d**
2. `O(n^d)`                         **if a < b^d (root heavy)**
3. `O(n^log_b(a)) = O(a^log_b(n))`  **if a > b^d (leaves heavy)**

*Note: In case 3 the base of the logarithm matters!*
</details>


### Quicksort
<details>

This is an implementation of [Randomized Quicksort](https://en.wikipedia.org/wiki/Quicksort).

#### Time Complexity
- Worst-Case `O(n^2)`
- Best-Case `O(nlogn)`
- Average Case `O(nlogn)`


#### Space Complexity
The space complexity is `O(1)` because we sort in-place.

```
/**
  * Sort the elements in the given array in-place between [left, right] inclusive using randomized quicksort.
  * @param left - The start index where left is less than the right.
  * @param right - The end index where left is less than the right
  */
private void quickSort(int[] nums, int left, int right) {
  if (left >= right) {
    return;
  }

  int pivot = getPivot(left, right);
  int partitionIndex = partition(nums, pivot, left, right);
  quickSort(nums, left, partitionIndex - 1);
  quickSort(nums, partitionIndex + 1, right);
}

/**
  * Pick a random pivot between left and right (inclusive).
  * @param left - The start index
  * @param right - The end index
  * @return int - The random pivot
  */
private int getPivot(int left, int right) {
  return random.nextInt(left, right + 1);
}
```
</details>


### Partition Around Pivot
<details>

To [partition](https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme) an array, around a pivot, means to move all elements in the array less than the pivot to the left of the pivot and all elements greater than or equal to the pivot to the right of the pivot. We return the index of the pivot element after the partition.

- Time Complexity `O(n)`
- Space Complexity `O(1)`


```
/**
  * Partition the given array nums between [left, right] around the given pivot and return the index of the pivot element.
  * @param nums - The array we want to partition
  * @param pivot - The element we want to partition this array with respect to
  * @param left - The start of the range
  * @param right - The end of the range
  * @return int - The index of the pivot element.
  */
private int partition(int[] nums, int pivot, int left, int right) {
  swap(nums, left, pivot);
  int swapIndex = left + 1;
  for (int j = left + 1; j <= right; j++) {
    if (nums[j] < nums[left]) {
      swap(nums, swapIndex, j);
      swapIndex += 1;
    }
  }
  swap(nums, swapIndex - 1, left);
  return swapIndex - 1;
}

/**
  * Swap the element at index x with the element at index y.
  * @param nums - The array in which we want to do a swap
  * @param x - The first index
  * @param y - The second index
  */
private void swap(int[] nums, int x, int y) {
  if (x < 0 || x >= nums.length || y < 0 || y >= nums.length) {
    return;
  }

  int tmp = nums[x];
  nums[x] = nums[y];
  nums[y] = tmp;
}
```
</details>